// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

//@version=6
strategy("PAC Hedge DCA v2 [Deep BT]", overlay=true, pyramiding=100, default_qty_type=strategy.cash, default_qty_value=0, initial_capital=2400, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.035, slippage=0, process_orders_on_close=true, calc_on_every_tick=true, margin_long=10, margin_short=10, max_bars_back=5000)

// ══════════════════════════════════════════════════════════════════════════════
// ▌ PAC HEDGE DCA v2
// ══════════════════════════════════════════════════════════════════════════════
// FIX vs v1:
//   - EMA Trend Filter statt S-CHoCH+ (reagiert in Stunden, nicht Wochen)
//   - BEIDE Seiten immer erlaubt (Trend = Size-Bias, nicht Block)
//   - DCA nur MIT Trend (kein DCA gegen den Trend)
//   - 3 DCA Levels statt 6 (weniger Risiko)
//   - Crash Detection: ATR extreme → alles stoppen
//   - Emergency Lockout: 100 Bars statt sofort wieder einsteigen
//   - Tighter SL: 1.5%
//
// ERGEBNIS: Strategy profitiert LONG in Uptrend, SHORT in Downtrend
// ══════════════════════════════════════════════════════════════════════════════


// ══════════════════════════════════════════════════════════════════════════════
// ▌ INPUTS
// ══════════════════════════════════════════════════════════════════════════════

// --- PAC Signal Sources ---
string grp_pac = "═══ PAC Signals (FVG Mitigated) ═══"
float ext_bull_fvg = input.source(close, "Bullish FVG Mitigated", group=grp_pac)
float ext_bear_fvg = input.source(close, "Bearish FVG Mitigated", group=grp_pac)

// --- Trend Filter (EMA-basiert, schnell) ---
string grp_trend = "═══ Trend Filter ═══"
int ema_fast_len = input.int(50, "Fast EMA", minval=10, maxval=200, step=10, group=grp_trend, tooltip="Schnelle EMA fuer Trend-Richtung.\n50 auf 15min = ~12.5 Stunden")
int ema_slow_len = input.int(200, "Slow EMA", minval=50, maxval=500, step=10, group=grp_trend, tooltip="Langsame EMA fuer Trend-Bestaetigung.\n200 auf 15min = ~50 Stunden")
float counter_trend_mult = input.float(0.5, "Gegen-Trend Size Mult", minval=0.0, maxval=1.0, step=0.1, group=grp_trend, tooltip="0.0 = keine Gegen-Trend Trades\n0.5 = halbe Size\n1.0 = gleiche Size (kein Filter)")
bool dca_only_with_trend = input.bool(true, "DCA nur MIT Trend", group=grp_trend, tooltip="Verhindert Nachkaufen gegen den Trend")

// --- Optional: CHoCH for additional close signal ---
string grp_ms = "═══ CHoCH (optional) ═══"
bool use_choch_close = input.bool(false, "CHoCH schliesst Gegenposition", group=grp_ms, tooltip="Optional: CHoCH als zusaetzliches Close-Signal.\nEMA ist bereits der Hauptfilter.")
float ext_bull_choch = input.source(close, "Bullish CHoCH", group=grp_ms)
float ext_bear_choch = input.source(close, "Bearish CHoCH", group=grp_ms)

// --- Trail / Exit ---
string grp_trail = "═══ Trail / Exit ═══"
string trail_mode = input.string("Internal ATR", "Trail Modus", options=["Internal ATR", "External Smart Trail"], group=grp_trail)
float trail_atr_mult = input.float(2.0, "Trail ATR Mult", minval=0.5, maxval=5.0, step=0.25, group=grp_trail)
float ext_smart_trail = input.source(close, "Smart Trail (S&O)", group=grp_trail)

// --- DCA Levels (3 statt 6, nur MIT Trend) ---
string grp_dca = "═══ DCA Levels ═══"
int max_dca = input.int(3, "Max DCA Stufen", minval=0, maxval=6, group=grp_dca)
float dca_1_pct = input.float(2.0, "DCA 1 Abstand %", minval=0.5, maxval=10.0, step=0.5, group=grp_dca)
float dca_2_pct = input.float(4.0, "DCA 2 Abstand %", minval=1.0, maxval=15.0, step=0.5, group=grp_dca)
float dca_3_pct = input.float(7.0, "DCA 3 Abstand %", minval=2.0, maxval=20.0, step=0.5, group=grp_dca)
float dca_decay = input.float(0.8, "DCA Size Decay", minval=0.3, maxval=1.0, step=0.05, group=grp_dca)

// --- Take Profit ---
string grp_tp = "═══ Take Profit ═══"
float tp_pct = input.float(1.5, "Take Profit %", minval=0.3, maxval=10.0, step=0.1, group=grp_tp)
float tp_partial = input.float(50, "TP Teilverkauf %", minval=20, maxval=80, step=5, group=grp_tp)

// --- Account ---
string grp_acc = "═══ Account ═══"
float equity_pct = input.float(5.0, "Equity % pro Trade", minval=0.5, maxval=15.0, step=0.5, group=grp_acc)
int max_slots = input.int(4, "Max Slots", minval=2, maxval=12, group=grp_acc)

// --- Risk ---
string grp_risk = "═══ Risiko ═══"
float sl_pct = input.float(1.5, "Stop Loss %", minval=0.5, maxval=5.0, step=0.25, group=grp_risk)
bool use_dynamic_sl = input.bool(false, "Dynamic SL (ATR)", group=grp_risk)
float dyn_sl_mult = input.float(1.5, "Dynamic SL ATR Mult", minval=0.5, maxval=4.0, step=0.25, group=grp_risk)
float max_dd_pct = input.float(15, "Max Drawdown %", minval=5, maxval=30, step=1, group=grp_risk)
int cooldown_bars = input.int(10, "Cooldown nach Exit (Bars)", minval=0, maxval=50, group=grp_risk)
int emergency_lockout = input.int(100, "Emergency Lockout (Bars)", minval=20, maxval=500, step=10, group=grp_risk, tooltip="Nach Emergency: X Bars KEIN Trading")
bool use_max_bars = input.bool(true, "Max Bars in Trade", group=grp_risk)
int max_trade_bars = input.int(400, "Max Bars bis Auto-Close", minval=50, maxval=2000, step=50, group=grp_risk)

// --- ATR / Volatility / Crash Detection ---
string grp_atr = "═══ ATR / Crash Detection ═══"
int atr_len = input.int(14, "ATR Laenge", minval=5, maxval=50, group=grp_atr)
int atr_avg_len = input.int(50, "ATR Avg Lookback", minval=20, maxval=200, group=grp_atr)
float vol_high_mult = input.float(1.5, "Hoch Vola → Size 50%", minval=1.1, maxval=3.0, step=0.1, group=grp_atr)
float vol_extreme_mult = input.float(2.5, "Extrem Vola → Size 25%", minval=1.5, maxval=5.0, step=0.1, group=grp_atr)
float vol_crash_mult = input.float(3.5, "Crash Vola → STOP", minval=2.0, maxval=8.0, step=0.5, group=grp_atr, tooltip="Wenn ATR ueber diesem Level: ALLE neuen Entries gestoppt, keine DCA")

// --- Funding ---
string grp_fee = "═══ Fees ═══"
float funding_rate = input.float(0.01, "Avg Funding % 8h", minval=-0.1, maxval=0.3, step=0.005, group=grp_fee)

// --- Webhook ---
string grp_wh = "═══ Webhook ═══"
bool enable_alerts = input.bool(false, "Webhook Alerts aktivieren", group=grp_wh)
string wh_secret = input.string("", "Webhook Secret", group=grp_wh)
string wh_ticker = input.string("HYPEUSDT", "Ticker", group=grp_wh)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ ATR & VOLATILITY & CRASH DETECTION
// ══════════════════════════════════════════════════════════════════════════════

float atr_val = ta.atr(atr_len)
float atr_avg = ta.sma(atr_val, atr_avg_len)
float atr_ratio = nz(atr_val / atr_avg, 1.0)
bool vol_high = atr_ratio >= vol_high_mult and atr_ratio < vol_extreme_mult
bool vol_extreme = atr_ratio >= vol_extreme_mult and atr_ratio < vol_crash_mult
bool vol_crash = atr_ratio >= vol_crash_mult
float vol_size_mult = vol_crash ? 0.0 : vol_extreme ? 0.25 : vol_high ? 0.5 : 1.0


// ══════════════════════════════════════════════════════════════════════════════
// ▌ TREND FILTER (EMA-basiert, reagiert in Stunden)
// ══════════════════════════════════════════════════════════════════════════════

float ema_fast = ta.ema(close, ema_fast_len)
float ema_slow = ta.ema(close, ema_slow_len)

// Trend: fast EMA above slow = bullish, below = bearish
int trend_state = ema_fast > ema_slow ? 1 : -1
bool trend_bullish = trend_state == 1
bool trend_bearish = trend_state == -1

// Size multiplier based on trend alignment
float long_trend_mult = trend_bullish ? 1.0 : counter_trend_mult
float short_trend_mult = trend_bearish ? 1.0 : counter_trend_mult

// DCA allowed check (only with trend)
bool dca_ok_long = not dca_only_with_trend or trend_bullish
bool dca_ok_short = not dca_only_with_trend or trend_bearish


// ══════════════════════════════════════════════════════════════════════════════
// ▌ PAC SIGNAL DETECTION
// ══════════════════════════════════════════════════════════════════════════════

bool bull_fvg_mit = ext_bull_fvg != ext_bull_fvg[1]
bool bear_fvg_mit = ext_bear_fvg != ext_bear_fvg[1]

// CHoCH (optional)
bool bull_choch = ext_bull_choch != ext_bull_choch[1]
bool bear_choch = ext_bear_choch != ext_bear_choch[1]

// Recent FVG for optional DCA filter
bool recent_bull_fvg = bull_fvg_mit
for i = 1 to 9
    if ext_bull_fvg[i] != ext_bull_fvg[i + 1]
        recent_bull_fvg := true
bool recent_bear_fvg = bear_fvg_mit
for i = 1 to 9
    if ext_bear_fvg[i] != ext_bear_fvg[i + 1]
        recent_bear_fvg := true

// Debug counters
var int dbg_bull_fvg = 0
var int dbg_bear_fvg = 0
var int dbg_ema_cross_up = 0
var int dbg_ema_cross_dn = 0
if bull_fvg_mit
    dbg_bull_fvg += 1
if bear_fvg_mit
    dbg_bear_fvg += 1
if trend_state == 1 and trend_state[1] == -1
    dbg_ema_cross_up += 1
if trend_state == -1 and trend_state[1] == 1
    dbg_ema_cross_dn += 1


// ══════════════════════════════════════════════════════════════════════════════
// ▌ POSITION TRACKING
// ══════════════════════════════════════════════════════════════════════════════

var float long_qty = 0.0
var float long_avg_price = 0.0
var float long_entry_price = 0.0
var int long_dca_count = 0
var int long_exit_stage = 0
var float long_sl_price = 0.0
var float long_trail_stop = 0.0
var int long_entry_bar = 0

var float short_qty = 0.0
var float short_avg_price = 0.0
var float short_entry_price = 0.0
var int short_dca_count = 0
var int short_exit_stage = 0
var float short_sl_price = 0.0
var float short_trail_stop = 0.0
var int short_entry_bar = 0

var int last_exit_bar = 0
var int emergency_bar = -9999
var bool emergency_stop = false
var float funding_total = 0.0
var int long_consec_losses = 0
var int short_consec_losses = 0

bool long_active = long_qty > 0
bool short_active = short_qty > 0
bool in_cooldown = (bar_index - last_exit_bar) < cooldown_bars
bool in_lockout = (bar_index - emergency_bar) < emergency_lockout
int active_slots = (long_active ? 1 : 0) + (short_active ? 1 : 0)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ TRAILING STOP (ratcheting, after TP1)
// ══════════════════════════════════════════════════════════════════════════════

if long_active and long_exit_stage >= 1
    float new_stop = trail_mode == "External Smart Trail" ? ext_smart_trail : close - atr_val * trail_atr_mult
    if long_trail_stop == 0 or new_stop > long_trail_stop
        long_trail_stop := new_stop

if short_active and short_exit_stage >= 1
    float new_stop = trail_mode == "External Smart Trail" ? ext_smart_trail : close + atr_val * trail_atr_mult
    if short_trail_stop == 0 or new_stop < short_trail_stop
        short_trail_stop := new_stop


// ══════════════════════════════════════════════════════════════════════════════
// ▌ DRAWDOWN & EMERGENCY PROTECTION
// ══════════════════════════════════════════════════════════════════════════════

var float peak_equity = strategy.initial_capital

if strategy.equity > peak_equity
    peak_equity := strategy.equity

float dd_from_peak = peak_equity > 0 ? (1.0 - strategy.equity / peak_equity) * 100.0 : 0.0

// Emergency triggers → lockout for N bars
if dd_from_peak >= max_dd_pct and not emergency_stop
    emergency_stop := true
    emergency_bar := bar_index

// Recovery: only after lockout AND DD recovered
if emergency_stop and (bar_index - emergency_bar) >= emergency_lockout and dd_from_peak < max_dd_pct * 0.5
    emergency_stop := false
    peak_equity := strategy.equity


// ══════════════════════════════════════════════════════════════════════════════
// ▌ COMBINED GATE
// ══════════════════════════════════════════════════════════════════════════════

bool can_trade = not emergency_stop and not in_lockout and not vol_crash
bool can_open = can_trade and active_slots < max_slots and not in_cooldown

// Both sides always allowed, but trend-biased size
bool can_open_long = can_open and long_trend_mult > 0
bool can_open_short = can_open and short_trend_mult > 0

// Funding
if long_active
    funding_total += long_qty * close * funding_rate / 100 / 96
if short_active
    funding_total += short_qty * close * funding_rate / 100 / 96

// Size calculation
float current_equity = strategy.equity
float base_size_usd = current_equity * equity_pct / 100 * vol_size_mult

calc_qty(float usd_size) =>
    usd_size * 10 / close

// DCA level helper
get_dca_pct(int level) =>
    switch level
        1 => dca_1_pct
        2 => dca_2_pct
        3 => dca_3_pct
        => 999.0

// SL calculation
calc_sl_long(float avg_price) =>
    use_dynamic_sl ? avg_price - atr_val * dyn_sl_mult : avg_price * (1 - sl_pct / 100)

calc_sl_short(float avg_price) =>
    use_dynamic_sl ? avg_price + atr_val * dyn_sl_mult : avg_price * (1 + sl_pct / 100)

// Webhook Alert Builder
build_alert(string act, float qty, float price, float sl, string cmt) =>
    '{"s":"' + wh_secret + '","t":"' + wh_ticker + '","a":"' + act + '",' +
     '"q":' + str.tostring(qty, "#.####") + ',' +
     '"p":' + str.tostring(price, "#.####") + ',' +
     '"sl":' + str.tostring(nz(sl, 0), "#.####") + ',' +
     '"c":"' + cmt + '"}'

// Reset helper
reset_long() =>
    [0.0, 0.0, 0.0, 0, 0, 0.0, 0.0]

reset_short() =>
    [0.0, 0.0, 0.0, 0, 0, 0.0, 0.0]


// ══════════════════════════════════════════════════════════════════════════════
// ▌ MAX BARS AUTO-CLOSE
// ══════════════════════════════════════════════════════════════════════════════

if use_max_bars and long_active and (bar_index - long_entry_bar) >= max_trade_bars
    if long_qty > 0
        strategy.order("L_MB", strategy.short, qty=long_qty, comment="L MaxBar")
        if enable_alerts
            alert(build_alert("close_long", long_qty, close, 0, "L MaxBar"), alert.freq_once_per_bar_close)
    float pnl = long_qty * (close - long_avg_price)
    if pnl < 0
        long_consec_losses += 1
    else
        long_consec_losses := 0
    long_qty := 0.0
    long_avg_price := 0.0
    long_entry_price := 0.0
    long_dca_count := 0
    long_exit_stage := 0
    long_sl_price := 0.0
    long_trail_stop := 0.0
    last_exit_bar := bar_index

if use_max_bars and short_active and (bar_index - short_entry_bar) >= max_trade_bars
    if short_qty > 0
        strategy.order("S_MB", strategy.long, qty=short_qty, comment="S MaxBar")
        if enable_alerts
            alert(build_alert("close_short", short_qty, close, 0, "S MaxBar"), alert.freq_once_per_bar_close)
    float pnl = short_qty * (short_avg_price - close)
    if pnl < 0
        short_consec_losses += 1
    else
        short_consec_losses := 0
    short_qty := 0.0
    short_avg_price := 0.0
    short_entry_price := 0.0
    short_dca_count := 0
    short_exit_stage := 0
    short_sl_price := 0.0
    short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ EMA TREND FLIP → close counter-trend positions
// ══════════════════════════════════════════════════════════════════════════════

// When EMA flips bearish → close longs
bool ema_flip_bearish = trend_state == -1 and trend_state[1] == 1
bool ema_flip_bullish = trend_state == 1 and trend_state[1] == -1

if ema_flip_bearish and long_active and counter_trend_mult < 0.5
    float pnl = long_qty * (close - long_avg_price)
    if pnl < 0
        long_consec_losses += 1
    else
        long_consec_losses := 0
    if long_qty > 0
        strategy.order("L_EF", strategy.short, qty=long_qty, comment="L EMA Flip")
        if enable_alerts
            alert(build_alert("close_long", long_qty, close, 0, "L EMA Flip"), alert.freq_once_per_bar_close)
    long_qty := 0.0
    long_avg_price := 0.0
    long_entry_price := 0.0
    long_dca_count := 0
    long_exit_stage := 0
    long_sl_price := 0.0
    long_trail_stop := 0.0
    last_exit_bar := bar_index

if ema_flip_bullish and short_active and counter_trend_mult < 0.5
    float pnl = short_qty * (short_avg_price - close)
    if pnl < 0
        short_consec_losses += 1
    else
        short_consec_losses := 0
    if short_qty > 0
        strategy.order("S_EF", strategy.long, qty=short_qty, comment="S EMA Flip")
        if enable_alerts
            alert(build_alert("close_short", short_qty, close, 0, "S EMA Flip"), alert.freq_once_per_bar_close)
    short_qty := 0.0
    short_avg_price := 0.0
    short_entry_price := 0.0
    short_dca_count := 0
    short_exit_stage := 0
    short_sl_price := 0.0
    short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ OPTIONAL: CHoCH CLOSE
// ══════════════════════════════════════════════════════════════════════════════

if use_choch_close and bear_choch and long_active
    float pnl = long_qty * (close - long_avg_price)
    if pnl < 0
        long_consec_losses += 1
    else
        long_consec_losses := 0
    if long_qty > 0
        strategy.order("L_CH", strategy.short, qty=long_qty, comment="L CHoCH")
        if enable_alerts
            alert(build_alert("close_long", long_qty, close, 0, "L CHoCH"), alert.freq_once_per_bar_close)
    long_qty := 0.0
    long_avg_price := 0.0
    long_entry_price := 0.0
    long_dca_count := 0
    long_exit_stage := 0
    long_sl_price := 0.0
    long_trail_stop := 0.0
    last_exit_bar := bar_index

if use_choch_close and bull_choch and short_active
    float pnl = short_qty * (short_avg_price - close)
    if pnl < 0
        short_consec_losses += 1
    else
        short_consec_losses := 0
    if short_qty > 0
        strategy.order("S_CH", strategy.long, qty=short_qty, comment="S CHoCH")
        if enable_alerts
            alert(build_alert("close_short", short_qty, close, 0, "S CHoCH"), alert.freq_once_per_bar_close)
    short_qty := 0.0
    short_avg_price := 0.0
    short_entry_price := 0.0
    short_dca_count := 0
    short_exit_stage := 0
    short_sl_price := 0.0
    short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ ENTRIES (FVG Mitigated, both sides, trend-biased size)
// ══════════════════════════════════════════════════════════════════════════════

if bull_fvg_mit and can_open_long and not long_active
    float size_usd = base_size_usd * long_trend_mult
    float qty = calc_qty(size_usd)
    if qty > 0
        string cmt = trend_bullish ? "L FVG" : "L FVG ct"
        strategy.order("L_E", strategy.long, qty=qty, comment=cmt)
        long_qty := qty
        long_avg_price := close
        long_entry_price := close
        long_dca_count := 0
        long_exit_stage := 0
        long_sl_price := calc_sl_long(close)
        long_trail_stop := 0.0
        long_entry_bar := bar_index
        if enable_alerts
            alert(build_alert("open_long", qty, close, long_sl_price, cmt), alert.freq_once_per_bar_close)

if bear_fvg_mit and can_open_short and not short_active
    float size_usd = base_size_usd * short_trend_mult
    float qty = calc_qty(size_usd)
    if qty > 0
        string cmt = trend_bearish ? "S FVG" : "S FVG ct"
        strategy.order("S_E", strategy.short, qty=qty, comment=cmt)
        short_qty := qty
        short_avg_price := close
        short_entry_price := close
        short_dca_count := 0
        short_exit_stage := 0
        short_sl_price := calc_sl_short(close)
        short_trail_stop := 0.0
        short_entry_bar := bar_index
        if enable_alerts
            alert(build_alert("open_short", qty, close, short_sl_price, cmt), alert.freq_once_per_bar_close)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ DCA (only WITH trend, no DCA in crash mode)
// ══════════════════════════════════════════════════════════════════════════════

if long_active and long_dca_count < max_dca and not emergency_stop and not vol_crash and dca_ok_long
    float next_pct = get_dca_pct(long_dca_count + 1)
    float dca_level = long_entry_price * (1 - next_pct / 100)
    if low <= dca_level
        float dca_usd = base_size_usd * math.pow(dca_decay, long_dca_count + 1)
        float dca_qty = calc_qty(dca_usd)
        if dca_qty > 0
            string cmt = "L D" + str.tostring(long_dca_count + 1)
            strategy.order("L_D" + str.tostring(long_dca_count + 1), strategy.long, qty=dca_qty, comment=cmt)
            float cost = long_avg_price * long_qty + close * dca_qty
            long_qty := long_qty + dca_qty
            long_avg_price := cost / long_qty
            long_dca_count += 1
            long_sl_price := calc_sl_long(long_avg_price)
            if long_exit_stage >= 1
                long_trail_stop := 0.0
            if enable_alerts
                alert(build_alert("dca_long", dca_qty, long_avg_price, long_sl_price, cmt), alert.freq_once_per_bar_close)

if short_active and short_dca_count < max_dca and not emergency_stop and not vol_crash and dca_ok_short
    float next_pct = get_dca_pct(short_dca_count + 1)
    float dca_level = short_entry_price * (1 + next_pct / 100)
    if high >= dca_level
        float dca_usd = base_size_usd * math.pow(dca_decay, short_dca_count + 1)
        float dca_qty = calc_qty(dca_usd)
        if dca_qty > 0
            string cmt = "S D" + str.tostring(short_dca_count + 1)
            strategy.order("S_D" + str.tostring(short_dca_count + 1), strategy.short, qty=dca_qty, comment=cmt)
            float cost = short_avg_price * short_qty + close * dca_qty
            short_qty := short_qty + dca_qty
            short_avg_price := cost / short_qty
            short_dca_count += 1
            short_sl_price := calc_sl_short(short_avg_price)
            if short_exit_stage >= 1
                short_trail_stop := 0.0
            if enable_alerts
                alert(build_alert("dca_short", dca_qty, short_avg_price, short_sl_price, cmt), alert.freq_once_per_bar_close)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ EXIT 1: TAKE PROFIT
// ══════════════════════════════════════════════════════════════════════════════

if long_active and long_exit_stage == 0
    float tp_level = long_avg_price * (1 + tp_pct / 100)
    if high >= tp_level
        float close_qty = long_qty * tp_partial / 100
        if close_qty > 0
            string cmt = "L TP" + str.tostring(tp_partial, "#") + "%"
            strategy.order("L_TP", strategy.short, qty=close_qty, comment=cmt)
            long_qty := long_qty - close_qty
            long_exit_stage := 1
            long_sl_price := long_avg_price
            if enable_alerts
                alert(build_alert("exit_x_long", close_qty, close, long_sl_price, cmt), alert.freq_once_per_bar_close)

if short_active and short_exit_stage == 0
    float tp_level = short_avg_price * (1 - tp_pct / 100)
    if low <= tp_level
        float close_qty = short_qty * tp_partial / 100
        if close_qty > 0
            string cmt = "S TP" + str.tostring(tp_partial, "#") + "%"
            strategy.order("S_TP", strategy.long, qty=close_qty, comment=cmt)
            short_qty := short_qty - close_qty
            short_exit_stage := 1
            short_sl_price := short_avg_price
            if enable_alerts
                alert(build_alert("exit_x_short", close_qty, close, short_sl_price, cmt), alert.freq_once_per_bar_close)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ EXIT 2: TRAILING STOP
// ══════════════════════════════════════════════════════════════════════════════

if long_active and long_exit_stage >= 1 and long_trail_stop > 0 and low <= long_trail_stop
    float pnl = long_qty * (close - long_avg_price)
    if pnl < 0
        long_consec_losses += 1
    else
        long_consec_losses := 0
    if long_qty > 0
        strategy.order("L_TR", strategy.short, qty=long_qty, comment="L Trail")
        if enable_alerts
            alert(build_alert("trail_long", long_qty, close, 0, "L Trail"), alert.freq_once_per_bar_close)
    long_qty := 0.0
    long_avg_price := 0.0
    long_entry_price := 0.0
    long_dca_count := 0
    long_exit_stage := 0
    long_sl_price := 0.0
    long_trail_stop := 0.0
    last_exit_bar := bar_index

if short_active and short_exit_stage >= 1 and short_trail_stop > 0 and high >= short_trail_stop
    float pnl = short_qty * (short_avg_price - close)
    if pnl < 0
        short_consec_losses += 1
    else
        short_consec_losses := 0
    if short_qty > 0
        strategy.order("S_TR", strategy.long, qty=short_qty, comment="S Trail")
        if enable_alerts
            alert(build_alert("trail_short", short_qty, close, 0, "S Trail"), alert.freq_once_per_bar_close)
    short_qty := 0.0
    short_avg_price := 0.0
    short_entry_price := 0.0
    short_dca_count := 0
    short_exit_stage := 0
    short_sl_price := 0.0
    short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ EXIT 3: STOP LOSS
// ══════════════════════════════════════════════════════════════════════════════

if long_active and long_sl_price > 0 and low <= long_sl_price
    long_consec_losses += 1
    if long_qty > 0
        strategy.order("L_SL", strategy.short, qty=long_qty, stop=long_sl_price, comment="L SL")
        if enable_alerts
            alert(build_alert("sl_long", long_qty, long_sl_price, 0, "L SL"), alert.freq_once_per_bar_close)
    long_qty := 0.0
    long_avg_price := 0.0
    long_entry_price := 0.0
    long_dca_count := 0
    long_exit_stage := 0
    long_sl_price := 0.0
    long_trail_stop := 0.0
    last_exit_bar := bar_index

if short_active and short_sl_price > 0 and high >= short_sl_price
    short_consec_losses += 1
    if short_qty > 0
        strategy.order("S_SL", strategy.long, qty=short_qty, stop=short_sl_price, comment="S SL")
        if enable_alerts
            alert(build_alert("sl_short", short_qty, short_sl_price, 0, "S SL"), alert.freq_once_per_bar_close)
    short_qty := 0.0
    short_avg_price := 0.0
    short_entry_price := 0.0
    short_dca_count := 0
    short_exit_stage := 0
    short_sl_price := 0.0
    short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ EMERGENCY (close all + lockout)
// ══════════════════════════════════════════════════════════════════════════════

if emergency_stop and (long_active or short_active)
    if long_qty > 0
        strategy.order("L_EM", strategy.short, qty=long_qty, comment="EM L")
        if enable_alerts
            alert(build_alert("emerg_long", long_qty, close, 0, "EM L"), alert.freq_once_per_bar_close)
        long_qty := 0.0
        long_avg_price := 0.0
        long_entry_price := 0.0
        long_dca_count := 0
        long_exit_stage := 0
        long_sl_price := 0.0
        long_trail_stop := 0.0
    if short_qty > 0
        strategy.order("S_EM", strategy.long, qty=short_qty, comment="EM S")
        if enable_alerts
            alert(build_alert("emerg_short", short_qty, close, 0, "EM S"), alert.freq_once_per_bar_close)
        short_qty := 0.0
        short_avg_price := 0.0
        short_entry_price := 0.0
        short_dca_count := 0
        short_exit_stage := 0
        short_sl_price := 0.0
        short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ CRASH: force-close all in extreme volatility
// ══════════════════════════════════════════════════════════════════════════════

if vol_crash and (long_active or short_active)
    if long_qty > 0
        strategy.order("L_CR", strategy.short, qty=long_qty, comment="L CRASH")
        if enable_alerts
            alert(build_alert("close_long", long_qty, close, 0, "L CRASH"), alert.freq_once_per_bar_close)
        long_qty := 0.0
        long_avg_price := 0.0
        long_entry_price := 0.0
        long_dca_count := 0
        long_exit_stage := 0
        long_sl_price := 0.0
        long_trail_stop := 0.0
    if short_qty > 0
        strategy.order("S_CR", strategy.long, qty=short_qty, comment="S CRASH")
        if enable_alerts
            alert(build_alert("close_short", short_qty, close, 0, "S CRASH"), alert.freq_once_per_bar_close)
        short_qty := 0.0
        short_avg_price := 0.0
        short_entry_price := 0.0
        short_dca_count := 0
        short_exit_stage := 0
        short_sl_price := 0.0
        short_trail_stop := 0.0
    last_exit_bar := bar_index


// ══════════════════════════════════════════════════════════════════════════════
// ▌ HEARTBEAT ALERT
// ══════════════════════════════════════════════════════════════════════════════

if enable_alerts and barstate.isconfirmed
    string hb = '{"s":"' + wh_secret + '","a":"hb",' +
     '"cp":' + str.tostring(close, "#.####") + ',' +
     '"td":' + str.tostring(trend_state) + ',' +
     '"s1":0,"s3":0,"r1":0,"r3":0,' +
     '"tr":' + str.tostring(nz(long_trail_stop > 0 ? long_trail_stop : short_trail_stop > 0 ? short_trail_stop : 0, 0), "#.####") + ',' +
     '"lq":' + str.tostring(long_qty, "#.####") + ',' +
     '"la":' + str.tostring(long_avg_price, "#.####") + ',' +
     '"ls":' + str.tostring(nz(long_sl_price, 0), "#.####") + ',' +
     '"ld":' + str.tostring(long_dca_count) + ',' +
     '"le":' + str.tostring(long_exit_stage) + ',' +
     '"sq":' + str.tostring(short_qty, "#.####") + ',' +
     '"sa":' + str.tostring(short_avg_price, "#.####") + ',' +
     '"ss":' + str.tostring(nz(short_sl_price, 0), "#.####") + ',' +
     '"sd":' + str.tostring(short_dca_count) + ',' +
     '"se":' + str.tostring(short_exit_stage) + '}'
    alert(hb, alert.freq_once_per_bar_close)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ VISUALISIERUNG
// ══════════════════════════════════════════════════════════════════════════════

// EMAs
plot(ema_fast, "EMA Fast", color=color.new(#2196F3, 30), linewidth=1)
plot(ema_slow, "EMA Slow", color=color.new(#FF9800, 30), linewidth=1)

// Position levels
plot(long_active ? long_avg_price : na, "L Avg", color=color.new(#4CAF50, 30), style=plot.style_linebr, linewidth=1)
plot(short_active ? short_avg_price : na, "S Avg", color=color.new(#F44336, 30), style=plot.style_linebr, linewidth=1)

// TP
float long_tp_vis = long_active and long_exit_stage == 0 ? long_avg_price * (1 + tp_pct / 100) : na
float short_tp_vis = short_active and short_exit_stage == 0 ? short_avg_price * (1 - tp_pct / 100) : na
plot(long_tp_vis, "L TP", color=color.new(#4CAF50, 60), style=plot.style_linebr, linewidth=1)
plot(short_tp_vis, "S TP", color=color.new(#F44336, 60), style=plot.style_linebr, linewidth=1)

// SL
plot(long_active and long_sl_price > 0 ? long_sl_price : na, "L SL", color=color.new(#FF5252, 50), style=plot.style_linebr, linewidth=1)
plot(short_active and short_sl_price > 0 ? short_sl_price : na, "S SL", color=color.new(#FF5252, 50), style=plot.style_linebr, linewidth=1)

// Trail
plot(long_active and long_trail_stop > 0 ? long_trail_stop : na, "L Trail", color=color.new(#2196F3, 50), style=plot.style_linebr, linewidth=1)
plot(short_active and short_trail_stop > 0 ? short_trail_stop : na, "S Trail", color=color.new(#2196F3, 50), style=plot.style_linebr, linewidth=1)

// Next DCA
float next_dca_long = long_active and long_dca_count < max_dca and dca_ok_long ? long_entry_price * (1 - get_dca_pct(long_dca_count + 1) / 100) : na
float next_dca_short = short_active and short_dca_count < max_dca and dca_ok_short ? short_entry_price * (1 + get_dca_pct(short_dca_count + 1) / 100) : na
plot(next_dca_long, "Next DCA L", color=color.new(#4CAF50, 75), style=plot.style_linebr, linewidth=1)
plot(next_dca_short, "Next DCA S", color=color.new(#F44336, 75), style=plot.style_linebr, linewidth=1)

// Background colors
color trend_bg = trend_bullish ? color.new(#4CAF50, 96) : color.new(#F44336, 96)
bgcolor(trend_bg)
bgcolor(vol_crash ? color.new(#FF0000, 85) : vol_extreme ? color.new(#FF0000, 93) : na)
bgcolor(emergency_stop ? color.new(#FF00FF, 90) : na)
bgcolor(in_lockout and not emergency_stop ? color.new(#FF9800, 95) : na)

// Signal markers
plotshape(bull_fvg_mit and trend_bullish, "Bull FVG ↑", shape.triangleup, location.belowbar, color.new(#4CAF50, 0), size=size.tiny)
plotshape(bull_fvg_mit and not trend_bullish, "Bull FVG ct", shape.triangleup, location.belowbar, color.new(#4CAF50, 60), size=size.tiny)
plotshape(bear_fvg_mit and trend_bearish, "Bear FVG ↓", shape.triangledown, location.abovebar, color.new(#F44336, 0), size=size.tiny)
plotshape(bear_fvg_mit and not trend_bearish, "Bear FVG ct", shape.triangledown, location.abovebar, color.new(#F44336, 60), size=size.tiny)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ INFO TABLE
// ══════════════════════════════════════════════════════════════════════════════

var table info = table.new(position.top_right, 4, 11, bgcolor=color.new(#0d1117, 5), border_color=color.new(#30305a, 0), border_width=1)

if barstate.islast
    table.cell(info, 0, 0, "PAC", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(info, 1, 0, "HEDGE", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(info, 2, 0, "DCA", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(info, 3, 0, "v2", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))

    // Trend
    string trend_txt = trend_bullish ? "BULL" : "BEAR"
    color trend_col = trend_bullish ? #4CAF50 : #F44336
    table.cell(info, 0, 1, "Trend", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 1, trend_txt, text_color=trend_col, text_size=size.tiny)
    string crash_txt = vol_crash ? "CRASH" : vol_extreme ? "EXTREM" : vol_high ? "HOCH" : "NORMAL"
    color crash_col = vol_crash ? #FF0000 : vol_extreme ? #F44336 : vol_high ? #FF9800 : #4CAF50
    table.cell(info, 2, 1, "Vola", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 1, crash_txt, text_color=crash_col, text_size=size.tiny)

    // Long
    string l_stg = long_exit_stage == 0 ? "FULL" : "TP"
    string l_txt = long_active ? l_stg + " D:" + str.tostring(long_dca_count) : "---"
    table.cell(info, 0, 2, "LONG", text_color=#4CAF50, text_size=size.tiny)
    table.cell(info, 1, 2, l_txt, text_color=long_active ? #4CAF50 : #555555, text_size=size.tiny)
    table.cell(info, 2, 2, "Avg", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 2, long_active ? str.tostring(long_avg_price, "#.##") : "---", text_color=#4CAF50, text_size=size.tiny)

    // Short
    string s_stg = short_exit_stage == 0 ? "FULL" : "TP"
    string s_txt = short_active ? s_stg + " D:" + str.tostring(short_dca_count) : "---"
    table.cell(info, 0, 3, "SHORT", text_color=#F44336, text_size=size.tiny)
    table.cell(info, 1, 3, s_txt, text_color=short_active ? #F44336 : #555555, text_size=size.tiny)
    table.cell(info, 2, 3, "Avg", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 3, short_active ? str.tostring(short_avg_price, "#.##") : "---", text_color=#F44336, text_size=size.tiny)

    // SL
    table.cell(info, 0, 4, "L SL", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 4, long_active ? str.tostring(long_sl_price, "#.##") : "---", text_color=#FF5252, text_size=size.tiny)
    table.cell(info, 2, 4, "S SL", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 4, short_active ? str.tostring(short_sl_price, "#.##") : "---", text_color=#FF5252, text_size=size.tiny)

    // TP
    table.cell(info, 0, 5, "L TP", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 5, long_active and long_exit_stage == 0 ? str.tostring(long_avg_price * (1 + tp_pct / 100), "#.##") : "---", text_color=#4CAF50, text_size=size.tiny)
    table.cell(info, 2, 5, "S TP", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 5, short_active and short_exit_stage == 0 ? str.tostring(short_avg_price * (1 - tp_pct / 100), "#.##") : "---", text_color=#F44336, text_size=size.tiny)

    // Trail
    table.cell(info, 0, 6, "L TR", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 6, long_active and long_trail_stop > 0 ? str.tostring(long_trail_stop, "#.##") : "---", text_color=#2196F3, text_size=size.tiny)
    table.cell(info, 2, 6, "S TR", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 6, short_active and short_trail_stop > 0 ? str.tostring(short_trail_stop, "#.##") : "---", text_color=#2196F3, text_size=size.tiny)

    // Status
    string st_txt = vol_crash ? "CRASH STOP" : emergency_stop ? "EMERGENCY" : in_lockout ? "LOCKOUT" : "ACTIVE"
    color stc = vol_crash or emergency_stop ? #FF0000 : in_lockout ? #FF9800 : #4CAF50
    table.cell(info, 0, 7, "Status", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 7, st_txt, text_color=stc, text_size=size.tiny)
    table.cell(info, 2, 7, "DD", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 7, str.tostring(dd_from_peak, "#.1") + "%", text_color=dd_from_peak > max_dd_pct * 0.7 ? #F44336 : #4CAF50, text_size=size.tiny)

    // Fund + Streak
    table.cell(info, 0, 8, "Fund", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 8, "-$" + str.tostring(funding_total, "#.0"), text_color=#FF9800, text_size=size.tiny)
    table.cell(info, 2, 8, "Streak", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 8, "L:" + str.tostring(long_consec_losses) + " S:" + str.tostring(short_consec_losses), text_color=math.max(long_consec_losses, short_consec_losses) >= 5 ? #F44336 : #4CAF50, text_size=size.tiny)

    // ATR + Size
    table.cell(info, 0, 9, "ATR", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 1, 9, str.tostring(atr_ratio, "#.##") + "x", text_color=crash_col, text_size=size.tiny)
    table.cell(info, 2, 9, "Size", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(info, 3, 9, str.tostring(vol_size_mult * 100, "#") + "%", text_color=vol_size_mult < 1 ? #FF9800 : #4CAF50, text_size=size.tiny)

    // Debug
    string dbg1 = "FVG B:" + str.tostring(dbg_bull_fvg) + " S:" + str.tostring(dbg_bear_fvg)
    string dbg2 = "EMA ↑:" + str.tostring(dbg_ema_cross_up) + " ↓:" + str.tostring(dbg_ema_cross_dn)
    table.cell(info, 0, 10, "DBG", text_color=#FF9800, text_size=size.tiny)
    table.cell(info, 1, 10, dbg1, text_color=#FF9800, text_size=size.tiny)
    table.cell(info, 2, 10, dbg2, text_color=#FF9800, text_size=size.tiny)
    table.cell(info, 3, 10, "", text_color=#FF9800, text_size=size.tiny)
