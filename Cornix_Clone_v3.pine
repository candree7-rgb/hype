// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/

//@version=6
strategy("Cornix Clone v3 [HYPE]", overlay=true, pyramiding=100, default_qty_type=strategy.cash, default_qty_value=0, initial_capital=2400, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.02, slippage=0, process_orders_on_close=true, calc_on_every_tick=true, margin_long=5, margin_short=5, max_bars_back=5000)

// ══════════════════════════════════════════════════════════════════════════════
// ▌ CORNIX CLONE v3 - BE-STOP ONLY (KEIN TRAILING!)
// ══════════════════════════════════════════════════════════════════════════════
//
// v2 PROBLEM: Trailing SL zu aggressiv → WR fiel von 57% auf 42%!
//   Trail schneidet Trades ab die eigentlich zum TP gelaufen wären.
//   Preis geht +0.3%, Trail aktiviert, Preis dippt → raus bei BE.
//   Ohne Trail wäre der Trade zum TP gelaufen.
//
// v3 FIX: NUR einmaliger Break-Even Move, KEIN dynamisches Trailing:
//   1. Preis erreicht +0.5% über Avg → SL springt zu Avg (BE)
//   2. SL BLEIBT bei Avg. Kein weiteres Trailing.
//   3. Trade hat vollen Raum zum TP (0.8%)
//   4. Mindestens 3 Bars nach Entry bevor BE aktiviert (Same-Bar-Schutz)
//
// Ergebnis: Trades werden nicht vorzeitig gekillt, aber Kapital ist
// geschützt sobald Position genug im Plus ist.
// ══════════════════════════════════════════════════════════════════════════════


// ══════════════════════════════════════════════════════════════════════════════
// ▌ INPUTS
// ══════════════════════════════════════════════════════════════════════════════

// --- Direction ---
string grp_dir = "═══ Direction ═══"
int ema_fast_len = input.int(50, "Fast EMA", minval=10, maxval=200, step=10, group=grp_dir)
int ema_slow_len = input.int(200, "Slow EMA", minval=50, maxval=500, step=10, group=grp_dir)
int adx_len = input.int(14, "ADX Laenge", minval=7, maxval=30, group=grp_dir)
int adx_smooth = input.int(14, "ADX Smoothing", minval=7, maxval=30, group=grp_dir)
float adx_range_thresh = input.float(20.0, "ADX Ranging (<X = beide Seiten)", minval=10, maxval=30, step=1, group=grp_dir)

// --- Entry Signal ---
string grp_entry = "═══ Entry Signal ═══"
int rsi_len = input.int(14, "RSI Laenge", minval=7, maxval=30, group=grp_entry)
float rsi_buy = input.float(35.0, "RSI Buy Level", minval=15, maxval=45, step=5, group=grp_entry)
float rsi_sell = input.float(65.0, "RSI Sell Level", minval=55, maxval=85, step=5, group=grp_entry)
int cooldown = input.int(3, "Cooldown Bars", minval=1, maxval=100, group=grp_entry, tooltip="Cornix: ~3000 Trades/3Mo = ~33/Tag")

// --- Take Profit ---
string grp_tp = "═══ Take Profit ═══"
float tp_pct = input.float(0.8, "Take Profit %", minval=0.1, maxval=3.0, step=0.1, group=grp_tp, tooltip="Cornix HYPE: ~0.82%")

// --- Break-Even Stop (einmalig, kein Trailing!) ---
string grp_be = "═══ Break-Even Stop (v3) ═══"
float be_activate_pct = input.float(0.5, "BE Aktivierung %", minval=0.1, maxval=1.0, step=0.05, group=grp_be, tooltip="Sobald Preis X% über Avg geht → SL = Avg.\nKein weiteres Trailing!\n0.5% = 62% des Weges zum TP (0.8%)")
int be_min_bars = input.int(3, "Min. Bars vor BE", minval=1, maxval=20, group=grp_be, tooltip="Verhindert Same-Bar Aktivierung.\n3 Bars = 45 Min auf 15min TF")

// --- DCA Levels (HYPE-spezifisch) ---
string grp_dca = "═══ DCA (6 Levels - HYPE) ═══"
float dca_1 = input.float(6.3, "E2 Abstand %", minval=1.0, maxval=15.0, step=0.5, group=grp_dca, tooltip="HYPE Cornix: ~6.3%")
float dca_2 = input.float(12.4, "E3 Abstand %", minval=3.0, maxval=20.0, step=0.5, group=grp_dca, tooltip="HYPE Cornix: ~12.4%")
float dca_3 = input.float(18.1, "E4 Abstand %", minval=5.0, maxval=30.0, step=1.0, group=grp_dca, tooltip="HYPE Cornix: ~18.1%")
float dca_4 = input.float(23.4, "E5 Abstand %", minval=10.0, maxval=40.0, step=1.0, group=grp_dca, tooltip="HYPE Cornix: ~23.4%")
float dca_5 = input.float(28.4, "E6 Abstand %", minval=15.0, maxval=50.0, step=1.0, group=grp_dca, tooltip="HYPE Cornix: ~28.4%")
int max_dca = input.int(5, "Max DCA Stufen", minval=1, maxval=5, group=grp_dca)

// --- DCA Size Multipliers ---
string grp_sz = "═══ DCA Sizing ═══"
float sz_1 = input.float(1.0, "E1 Size (Basis)", group=grp_sz)
float sz_2 = input.float(1.0, "E2 Size Mult", group=grp_sz)
float sz_3 = input.float(1.5, "E3 Size Mult", group=grp_sz)
float sz_4 = input.float(2.0, "E4 Size Mult", group=grp_sz)
float sz_5 = input.float(2.5, "E5 Size Mult", group=grp_sz)
float sz_6 = input.float(3.0, "E6 Size Mult", group=grp_sz)

// --- Account ---
string grp_acc = "═══ Account ═══"
float equity_pct = input.float(1.0, "Equity % pro Entry 1", minval=0.1, maxval=5.0, step=0.1, group=grp_acc)

// --- Fester Stop Loss (Notfall) ---
string grp_sl = "═══ Fester SL (Notfall) ═══"
float sl_buffer_pct = input.float(5.0, "SL Buffer % unter E6", minval=2.0, maxval=15.0, step=1.0, group=grp_sl, tooltip="Fester SL = E6 - Buffer. Absolute Notbremse.")


// ══════════════════════════════════════════════════════════════════════════════
// ▌ CALCULATIONS
// ══════════════════════════════════════════════════════════════════════════════

float ema_fast = ta.ema(close, ema_fast_len)
float ema_slow = ta.ema(close, ema_slow_len)
bool uptrend = ema_fast > ema_slow
bool downtrend = ema_fast < ema_slow

[di_plus, di_minus, adx_val] = ta.dmi(adx_len, adx_smooth)
bool is_ranging = adx_val < adx_range_thresh

float rsi = ta.rsi(close, rsi_len)

bool allow_long = uptrend or is_ranging
bool allow_short = downtrend or is_ranging

bool long_signal = allow_long and rsi < rsi_buy
bool short_signal = allow_short and rsi > rsi_sell


// ══════════════════════════════════════════════════════════════════════════════
// ▌ POSITION TRACKING
// ══════════════════════════════════════════════════════════════════════════════

var float long_qty = 0.0
var float long_avg = 0.0
var float long_entry = 0.0
var int long_dca = 0
var int long_bar = 0
var bool long_be_active = false    // BE Stop aktiviert?

var float short_qty = 0.0
var float short_avg = 0.0
var float short_entry = 0.0
var int short_dca = 0
var int short_bar = 0
var bool short_be_active = false

var int last_long = -9999
var int last_short = -9999
var int wins = 0
var int losses = 0
var int be_stops = 0

bool l_active = long_qty > 0
bool s_active = short_qty > 0

// DCA helpers
get_dca_pct(int lvl) =>
    switch lvl
        1 => dca_1
        2 => dca_2
        3 => dca_3
        4 => dca_4
        5 => dca_5
        => 999.0

get_dca_sz(int lvl) =>
    switch lvl
        0 => sz_1
        1 => sz_2
        2 => sz_3
        3 => sz_4
        4 => sz_5
        5 => sz_6
        => 1.0

float base_usd = strategy.equity * equity_pct / 100
calc_qty(float usd) => usd * 20 / close


// ══════════════════════════════════════════════════════════════════════════════
// ▌ BREAK-EVEN STOP AKTIVIERUNG (einmalig, kein Trailing!)
// ══════════════════════════════════════════════════════════════════════════════

// Long: Prüfe ob BE aktiviert werden soll
if l_active and not long_be_active
    bool enough_bars = (bar_index - long_bar) >= be_min_bars
    float activate_level = long_avg * (1 + be_activate_pct / 100)
    if enough_bars and high >= activate_level
        long_be_active := true

// Short: Prüfe ob BE aktiviert werden soll
if s_active and not short_be_active
    bool enough_bars = (bar_index - short_bar) >= be_min_bars
    float activate_level = short_avg * (1 - be_activate_pct / 100)
    if enough_bars and low <= activate_level
        short_be_active := true


// ══════════════════════════════════════════════════════════════════════════════
// ▌ TAKE PROFIT
// ══════════════════════════════════════════════════════════════════════════════

if l_active
    float tp = long_avg * (1 + tp_pct / 100)
    if high >= tp
        if long_qty > 0
            strategy.order("L_TP", strategy.short, qty=long_qty, comment="L TP")
        wins += 1
        long_qty := 0.0
        long_avg := 0.0
        long_entry := 0.0
        long_dca := 0
        long_be_active := false

if s_active
    float tp = short_avg * (1 - tp_pct / 100)
    if low <= tp
        if short_qty > 0
            strategy.order("S_TP", strategy.long, qty=short_qty, comment="S TP")
        wins += 1
        short_qty := 0.0
        short_avg := 0.0
        short_entry := 0.0
        short_dca := 0
        short_be_active := false


// ══════════════════════════════════════════════════════════════════════════════
// ▌ BREAK-EVEN STOP EXIT
// ══════════════════════════════════════════════════════════════════════════════

// Long: BE ist aktiv → wenn Preis zurück zum Avg fällt, raus bei BE
if l_active and long_be_active
    if low <= long_avg
        if long_qty > 0
            strategy.order("L_BE", strategy.short, qty=long_qty, comment="L BE")
        be_stops += 1
        long_qty := 0.0
        long_avg := 0.0
        long_entry := 0.0
        long_dca := 0
        long_be_active := false

// Short: BE ist aktiv → wenn Preis zurück zum Avg steigt, raus bei BE
if s_active and short_be_active
    if high >= short_avg
        if short_qty > 0
            strategy.order("S_BE", strategy.long, qty=short_qty, comment="S BE")
        be_stops += 1
        short_qty := 0.0
        short_avg := 0.0
        short_entry := 0.0
        short_dca := 0
        short_be_active := false


// ══════════════════════════════════════════════════════════════════════════════
// ▌ DCA (6 levels, HYPE spacing)
// ══════════════════════════════════════════════════════════════════════════════

if l_active and long_dca < max_dca
    float pct = get_dca_pct(long_dca + 1)
    float lvl = long_entry * (1 - pct / 100)
    if low <= lvl
        float usd = base_usd * get_dca_sz(long_dca + 1)
        float qty = calc_qty(usd)
        if qty > 0
            string c = "L E" + str.tostring(long_dca + 2)
            strategy.order("L_D" + str.tostring(long_dca + 1), strategy.long, qty=qty, comment=c)
            float cost = long_avg * long_qty + close * qty
            long_qty := long_qty + qty
            long_avg := cost / long_qty
            long_dca += 1
            // Reset BE bei DCA (neuer Avg = neuer BE-Referenz)
            long_be_active := false

if s_active and short_dca < max_dca
    float pct = get_dca_pct(short_dca + 1)
    float lvl = short_entry * (1 + pct / 100)
    if high >= lvl
        float usd = base_usd * get_dca_sz(short_dca + 1)
        float qty = calc_qty(usd)
        if qty > 0
            string c = "S E" + str.tostring(short_dca + 2)
            strategy.order("S_D" + str.tostring(short_dca + 1), strategy.short, qty=qty, comment=c)
            float cost = short_avg * short_qty + close * qty
            short_qty := short_qty + qty
            short_avg := cost / short_qty
            short_dca += 1
            // Reset BE bei DCA
            short_be_active := false


// ══════════════════════════════════════════════════════════════════════════════
// ▌ ENTRIES
// ══════════════════════════════════════════════════════════════════════════════

bool l_cd = (bar_index - last_long) >= cooldown
bool s_cd = (bar_index - last_short) >= cooldown

if long_signal and not l_active and l_cd
    float qty = calc_qty(base_usd * sz_1)
    if qty > 0
        strategy.order("L_E", strategy.long, qty=qty, comment="L E1")
        long_qty := qty
        long_avg := close
        long_entry := close
        long_dca := 0
        long_bar := bar_index
        last_long := bar_index
        long_be_active := false

if short_signal and not s_active and s_cd
    float qty = calc_qty(base_usd * sz_1)
    if qty > 0
        strategy.order("S_E", strategy.short, qty=qty, comment="S E1")
        short_qty := qty
        short_avg := close
        short_entry := close
        short_dca := 0
        short_bar := bar_index
        last_short := bar_index
        short_be_active := false


// ══════════════════════════════════════════════════════════════════════════════
// ▌ FESTER STOP LOSS (Notfall - unter E6)
// ══════════════════════════════════════════════════════════════════════════════

if l_active and not long_be_active
    float e6 = long_entry * (1 - dca_5 / 100)
    float sl = e6 * (1 - sl_buffer_pct / 100)
    if low <= sl
        if long_qty > 0
            strategy.order("L_SL", strategy.short, qty=long_qty, comment="L SL")
        losses += 1
        long_qty := 0.0
        long_avg := 0.0
        long_entry := 0.0
        long_dca := 0
        long_be_active := false

if s_active and not short_be_active
    float e6 = short_entry * (1 + dca_5 / 100)
    float sl = e6 * (1 + sl_buffer_pct / 100)
    if high >= sl
        if short_qty > 0
            strategy.order("S_SL", strategy.long, qty=short_qty, comment="S SL")
        losses += 1
        short_qty := 0.0
        short_avg := 0.0
        short_entry := 0.0
        short_dca := 0
        short_be_active := false


// ══════════════════════════════════════════════════════════════════════════════
// ▌ VISUALISIERUNG
// ══════════════════════════════════════════════════════════════════════════════

plot(ema_fast, "EMA 50", color=color.new(#2196F3, 40), linewidth=1)
plot(ema_slow, "EMA 200", color=color.new(#FF9800, 40), linewidth=1)

plot(l_active ? long_avg : na, "L Avg", color=color.new(#4CAF50, 30), style=plot.style_linebr, linewidth=1)
plot(s_active ? short_avg : na, "S Avg", color=color.new(#F44336, 30), style=plot.style_linebr, linewidth=1)
plot(l_active ? long_avg * (1 + tp_pct / 100) : na, "L TP", color=color.new(#4CAF50, 50), style=plot.style_linebr, linewidth=2)
plot(s_active ? short_avg * (1 - tp_pct / 100) : na, "S TP", color=color.new(#F44336, 50), style=plot.style_linebr, linewidth=2)

// BE Stop Level (gelb wenn aktiv)
plot(l_active and long_be_active ? long_avg : na, "L BE", color=color.new(#FFEB3B, 30), style=plot.style_linebr, linewidth=2)
plot(s_active and short_be_active ? short_avg : na, "S BE", color=color.new(#FFEB3B, 30), style=plot.style_linebr, linewidth=2)

// DCA levels
plot(l_active and long_dca < 1 ? long_entry * (1 - dca_1/100) : na, "L E2", color=color.new(#4CAF50, 70), style=plot.style_linebr)
plot(l_active and long_dca < 2 ? long_entry * (1 - dca_2/100) : na, "L E3", color=color.new(#4CAF50, 80), style=plot.style_linebr)
plot(s_active and short_dca < 1 ? short_entry * (1 + dca_1/100) : na, "S E2", color=color.new(#F44336, 70), style=plot.style_linebr)
plot(s_active and short_dca < 2 ? short_entry * (1 + dca_2/100) : na, "S E3", color=color.new(#F44336, 80), style=plot.style_linebr)

// Fester SL level
float l_sl = l_active and not long_be_active ? long_entry * (1 - dca_5/100) * (1 - sl_buffer_pct/100) : na
float s_sl = s_active and not short_be_active ? short_entry * (1 + dca_5/100) * (1 + sl_buffer_pct/100) : na
plot(l_sl, "L SL", color=color.new(#FF0000, 60), style=plot.style_linebr, linewidth=1)
plot(s_sl, "S SL", color=color.new(#FF0000, 60), style=plot.style_linebr, linewidth=1)

// Background
bgcolor(is_ranging ? color.new(#9C27B0, 95) : uptrend ? color.new(#4CAF50, 96) : color.new(#F44336, 96))

plotshape(long_signal and not l_active and l_cd, "Buy", shape.triangleup, location.belowbar, color.new(#4CAF50, 0), size=size.tiny)
plotshape(short_signal and not s_active and s_cd, "Sell", shape.triangledown, location.abovebar, color.new(#F44336, 0), size=size.tiny)


// ══════════════════════════════════════════════════════════════════════════════
// ▌ INFO TABLE
// ══════════════════════════════════════════════════════════════════════════════

var table t = table.new(position.top_right, 4, 11, bgcolor=color.new(#0d1117, 5), border_color=color.new(#30305a, 0), border_width=1)

if barstate.islast
    table.cell(t, 0, 0, "CORNIX", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(t, 1, 0, "CLONE", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(t, 2, 0, "BE", text_color=#FFEB3B, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))
    table.cell(t, 3, 0, "v3", text_color=#00d4ff, text_size=size.tiny, bgcolor=color.new(#0d1117, 0))

    string mode = is_ranging ? "RANGE" : uptrend ? "BULL" : "BEAR"
    color mc = is_ranging ? #9C27B0 : uptrend ? #4CAF50 : #F44336
    table.cell(t, 0, 1, "Mode", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 1, mode, text_color=mc, text_size=size.tiny)
    table.cell(t, 2, 1, "ADX", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 1, str.tostring(adx_val, "#.#"), text_color=mc, text_size=size.tiny)

    table.cell(t, 0, 2, "RSI", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 2, str.tostring(rsi, "#.#"), text_color=rsi < rsi_buy ? #4CAF50 : rsi > rsi_sell ? #F44336 : #aaaaaa, text_size=size.tiny)
    table.cell(t, 2, 2, "TP%", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 2, str.tostring(tp_pct, "#.#") + "%", text_color=#aaaaaa, text_size=size.tiny)

    table.cell(t, 0, 3, "LONG", text_color=#4CAF50, text_size=size.tiny)
    table.cell(t, 1, 3, l_active ? "E" + str.tostring(long_dca + 1) : "---", text_color=l_active ? #4CAF50 : #555555, text_size=size.tiny)
    table.cell(t, 2, 3, "Avg", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 3, l_active ? str.tostring(long_avg, "#.##") : "---", text_color=#4CAF50, text_size=size.tiny)

    table.cell(t, 0, 4, "SHORT", text_color=#F44336, text_size=size.tiny)
    table.cell(t, 1, 4, s_active ? "E" + str.tostring(short_dca + 1) : "---", text_color=s_active ? #F44336 : #555555, text_size=size.tiny)
    table.cell(t, 2, 4, "Avg", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 4, s_active ? str.tostring(short_avg, "#.##") : "---", text_color=#F44336, text_size=size.tiny)

    // BE Status
    string l_be_str = l_active ? (long_be_active ? "AKTIV" : "WAIT") : "---"
    string s_be_str = s_active ? (short_be_active ? "AKTIV" : "WAIT") : "---"
    table.cell(t, 0, 5, "L BE", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 5, l_be_str, text_color=long_be_active ? #FFEB3B : #555555, text_size=size.tiny)
    table.cell(t, 2, 5, "S BE", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 5, s_be_str, text_color=short_be_active ? #FFEB3B : #555555, text_size=size.tiny)

    // Win Rate
    int total = wins + losses + be_stops
    float wr = total > 0 ? wins * 100.0 / total : 0.0
    table.cell(t, 0, 6, "WR", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 6, str.tostring(wr, "#.#") + "%", text_color=wr > 90 ? #4CAF50 : wr > 70 ? #FF9800 : #F44336, text_size=size.tiny)
    table.cell(t, 2, 6, "W/L/BE", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 6, str.tostring(wins) + "/" + str.tostring(losses) + "/" + str.tostring(be_stops), text_color=#aaaaaa, text_size=size.tiny)

    // DCA depth
    table.cell(t, 0, 7, "L DCA", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 7, l_active ? str.tostring(long_dca) + "/5" : "---", text_color=long_dca > 3 ? #F44336 : long_dca > 1 ? #FF9800 : #4CAF50, text_size=size.tiny)
    table.cell(t, 2, 7, "S DCA", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 7, s_active ? str.tostring(short_dca) + "/5" : "---", text_color=short_dca > 3 ? #F44336 : short_dca > 1 ? #FF9800 : #4CAF50, text_size=size.tiny)

    // Next DCA
    float next_l = l_active and long_dca < max_dca ? long_entry * (1 - get_dca_pct(long_dca + 1)/100) : na
    float next_s = s_active and short_dca < max_dca ? short_entry * (1 + get_dca_pct(short_dca + 1)/100) : na
    table.cell(t, 0, 8, "Nxt L", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 8, na(next_l) ? "---" : str.tostring(next_l, "#.##"), text_color=#4CAF50, text_size=size.tiny)
    table.cell(t, 2, 8, "Nxt S", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 8, na(next_s) ? "---" : str.tostring(next_s, "#.##"), text_color=#F44336, text_size=size.tiny)

    // Exposure
    float l_exp = l_active ? long_qty * close / strategy.equity * 100 : 0.0
    float s_exp = s_active ? short_qty * close / strategy.equity * 100 : 0.0
    table.cell(t, 0, 9, "L Exp", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 9, str.tostring(l_exp, "#.#") + "%", text_color=l_exp > 100 ? #F44336 : #aaaaaa, text_size=size.tiny)
    table.cell(t, 2, 9, "S Exp", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 9, str.tostring(s_exp, "#.#") + "%", text_color=s_exp > 100 ? #F44336 : #aaaaaa, text_size=size.tiny)

    table.cell(t, 0, 10, "Lev", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 1, 10, "20x", text_color=#FF9800, text_size=size.tiny)
    table.cell(t, 2, 10, "DCA", text_color=#aaaaaa, text_size=size.tiny)
    table.cell(t, 3, 10, "HYPE", text_color=#FF9800, text_size=size.tiny)
